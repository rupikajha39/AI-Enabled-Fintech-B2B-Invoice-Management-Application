{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Rupika.LAPTOP-K3QFEE6T\\\\Downloads\\\\HRC70695W-front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { GridEvents } from '../../../models/events';\nexport var GRID_DEFAULT_STRATEGY = 'none';\nexport var GRID_STRATEGIES_PROCESSORS = {\n  rowTreeCreation: 'rowTree',\n  filtering: 'rowTree',\n  sorting: 'rowTree'\n};\n/**\n * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)\n *\n * Some plugins contain custom logic that must only be run if the right strategy is active.\n * For instance, the tree data plugin has:\n * - custom row tree creation algorithm.\n * - custom sorting algorithm.\n * - custom filtering algorithm.\n *\n * These plugins must use:\n * - `apiRef.current.unstable_registerStrategyProcessor` to register their processors.\n * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.\n *\n * Some hooks need to run the custom logic of the active strategy.\n * For instance, the `useGridFiltering` wants to run:\n * - the tree data filtering if the tree data is the current way of grouping rows.\n * - the row grouping filtering if the row grouping is the current way of grouping rows.\n * - the flat filtering if there is no grouping of the rows (equivalent to the \"none\" strategy).\n *\n * These hooks must use:\n * - `apiRef.current.unstable_applyStrategyProcessor` to run a processor.\n * - `GridEvents.strategyAvailabilityChange` to update something when the active strategy changes.\n *    Warning: Be careful not to apply the processor several times.\n *    For instance `GridEvents.rowsSet` is fired by `useGridRows` whenever the active strategy changes.\n *    So listening to both would most likely run your logic twice.\n * - `GridEvents.activeStrategyProcessorChange` to update something when the processor of the active strategy changes\n *\n * Each processor name is part of a strategy group which can only have one active strategy at the time.\n */\n\nexport var useGridStrategyProcessing = function useGridStrategyProcessing(apiRef) {\n  var availableStrategies = React.useRef(new Map());\n  var strategiesCache = React.useRef({});\n  var registerStrategyProcessor = React.useCallback(function (strategyName, processorName, processor) {\n    var cleanup = function cleanup() {\n      var _ref = strategiesCache.current[processorName],\n          otherProcessors = _objectWithoutPropertiesLoose(_ref, [strategyName].map(_toPropertyKey));\n\n      strategiesCache.current[processorName] = otherProcessors;\n    };\n\n    if (!strategiesCache.current[processorName]) {\n      strategiesCache.current[processorName] = {};\n    }\n\n    var groupPreProcessors = strategiesCache.current[processorName];\n    var previousProcessor = groupPreProcessors[strategyName];\n    groupPreProcessors[strategyName] = processor;\n\n    if (!previousProcessor || previousProcessor === processor) {\n      return cleanup;\n    }\n\n    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {\n      apiRef.current.publishEvent(GridEvents.activeStrategyProcessorChange, processorName);\n    }\n\n    return cleanup;\n  }, [apiRef]);\n  var applyStrategyProcessor = React.useCallback(function (processorName, params) {\n    var activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);\n\n    if (activeStrategy == null) {\n      throw new Error(\"Can't apply a strategy processor before defining an active strategy\");\n    }\n\n    var groupCache = strategiesCache.current[processorName];\n\n    if (!groupCache || !groupCache[activeStrategy]) {\n      throw new Error(\"No processor found for processor \\\"\".concat(processorName, \"\\\" on strategy \\\"\").concat(activeStrategy, \"\\\"\"));\n    }\n\n    var processor = groupCache[activeStrategy];\n    return processor(params);\n  }, [apiRef]);\n  var getActiveStrategy = React.useCallback(function (strategyGroup) {\n    var _availableStrategyEnt;\n\n    var strategyEntries = Array.from(availableStrategies.current.entries());\n    var availableStrategyEntry = strategyEntries.find(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          strategy = _ref3[1];\n\n      if (strategy.group !== strategyGroup) {\n        return false;\n      }\n\n      return strategy.isAvailable();\n    });\n    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;\n  }, []);\n  var setStrategyAvailability = React.useCallback(function (strategyGroup, strategyName, isAvailable) {\n    availableStrategies.current.set(strategyName, {\n      group: strategyGroup,\n      isAvailable: isAvailable\n    });\n    apiRef.current.publishEvent(GridEvents.strategyAvailabilityChange);\n  }, [apiRef]);\n  var strategyProcessingApi = {\n    unstable_registerStrategyProcessor: registerStrategyProcessor,\n    unstable_applyStrategyProcessor: applyStrategyProcessor,\n    unstable_getActiveStrategy: getActiveStrategy,\n    unstable_setStrategyAvailability: setStrategyAvailability\n  };\n  useGridApiMethod(apiRef, strategyProcessingApi, 'GridStrategyProcessing');\n};","map":null,"metadata":{},"sourceType":"module"}