{"ast":null,"code":"import _defineProperty from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useEventCallback } from '@mui/material/utils';\nimport { useGridApiOptionHandler, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { GridEvents } from '../../../models/events/gridEvents';\nimport { GridCellModes, GridEditModes } from '../../../models/gridEditRowModel';\nimport { isKeyboardEvent, isPrintableKey, isCellEnterEditModeKeys, isCellExitEditModeKeys, isCellEditCommitKeys, isDeleteKeys } from '../../../utils/keyboardUtils';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridEditRowsStateSelector } from './gridEditRowsSelector';\n\nfunction isPromise(promise) {\n  return typeof promise.then === 'function';\n}\n\nexport var useCellEditing = function useCellEditing(apiRef, props) {\n  var _props$experimentalFe2;\n\n  var logger = useGridLogger(apiRef, 'useGridEditRows');\n\n  var buildCallback = function buildCallback(callback) {\n    return function () {\n      if (props.editMode === GridEditModes.Cell) {\n        callback.apply(void 0, arguments);\n      }\n    };\n  };\n\n  var setCellMode = React.useCallback(function (id, field, mode) {\n    if (apiRef.current.getCellMode(id, field) === mode) {\n      return;\n    }\n\n    logger.debug(\"Switching cell id: \".concat(id, \" field: \").concat(field, \" to mode: \").concat(mode));\n    apiRef.current.setState(function (state) {\n      var newEditRowsState = _extends({}, state.editRows);\n\n      newEditRowsState[id] = _extends({}, newEditRowsState[id]);\n\n      if (mode === GridCellModes.Edit) {\n        newEditRowsState[id][field] = {\n          value: apiRef.current.getCellValue(id, field)\n        };\n      } else {\n        delete newEditRowsState[id][field];\n\n        if (!Object.keys(newEditRowsState[id]).length) {\n          delete newEditRowsState[id];\n        }\n      }\n\n      return _extends({}, state, {\n        editRows: newEditRowsState\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.cellModeChange, apiRef.current.getCellParams(id, field));\n  }, [apiRef, logger]);\n  var getCellMode = React.useCallback(function (id, field) {\n    var editRowsState = gridEditRowsStateSelector(apiRef.current.state);\n    var isEditing = editRowsState[id] && editRowsState[id][field];\n    return isEditing ? GridCellModes.Edit : GridCellModes.View;\n  }, [apiRef]); // TODO v6: it should always return a promise\n\n  var commitCellChange = React.useCallback(function (params) {\n    var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _props$experimentalFe;\n\n    var id = params.id,\n        field = params.field;\n    apiRef.current.unstable_runPendingEditCellValueMutation(id, field);\n    var model = apiRef.current.getEditRowsModel();\n\n    if (!model[id] || !model[id][field]) {\n      throw new Error(\"MUI: Cell at id: \".concat(id, \" and field: \").concat(field, \" is not in edit mode.\"));\n    }\n\n    var editCellProps = model[id][field];\n    var column = apiRef.current.getColumn(field);\n    var row = apiRef.current.getRow(id);\n\n    if ((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.preventCommitWhileValidating) {\n      var cellProps = model[id][field];\n\n      if (cellProps.isValidating || cellProps.error) {\n        return false;\n      }\n    }\n\n    var commitParams = _extends({}, params, {\n      value: editCellProps.value\n    });\n\n    var hasError = !!editCellProps.error;\n\n    if (!hasError && typeof column.preProcessEditCellProps === 'function') {\n      var result = column.preProcessEditCellProps({\n        id: id,\n        row: row,\n        props: editCellProps\n      });\n\n      if (isPromise(result)) {\n        return result.then(function (newEditCellProps) {\n          apiRef.current.unstable_setEditCellProps({\n            id: id,\n            field: field,\n            props: newEditCellProps\n          });\n\n          if (newEditCellProps.error) {\n            return false;\n          }\n\n          apiRef.current.publishEvent(GridEvents.cellEditCommit, commitParams, event);\n          return true;\n        });\n      }\n\n      apiRef.current.unstable_setEditCellProps({\n        id: id,\n        field: field,\n        props: result\n      });\n      hasError = !!result.error;\n    }\n\n    if (!hasError) {\n      apiRef.current.publishEvent(GridEvents.cellEditCommit, commitParams, event);\n      return true;\n    }\n\n    return false;\n  }, [apiRef, (_props$experimentalFe2 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe2.preventCommitWhileValidating]);\n  var setCellEditingEditCellValue = React.useCallback(function (params) {\n    var column = apiRef.current.getColumn(params.field);\n    var row = apiRef.current.getRow(params.id);\n    return new Promise(function (resolve) {\n      var newEditCellProps = {\n        value: params.value\n      };\n      var model = apiRef.current.getEditRowsModel();\n      var editCellProps = model[params.id][params.field];\n\n      if (typeof column.preProcessEditCellProps !== 'function') {\n        apiRef.current.unstable_setEditCellProps(_extends({}, params, {\n          props: newEditCellProps\n        }));\n        resolve(true);\n        return;\n      } // setEditCellProps runs the value parser and returns the updated props\n\n\n      newEditCellProps = apiRef.current.unstable_setEditCellProps(_extends({}, params, {\n        props: _extends({}, editCellProps, {\n          isValidating: true\n        })\n      }));\n      Promise.resolve(column.preProcessEditCellProps({\n        id: params.id,\n        row: row,\n        props: _extends({}, newEditCellProps, {\n          value: apiRef.current.unstable_parseValue(params.id, params.field, params.value)\n        })\n      })).then(function (newEditCellPropsProcessed) {\n        apiRef.current.unstable_setEditCellProps(_extends({}, params, {\n          props: _extends({}, newEditCellPropsProcessed, {\n            isValidating: false\n          })\n        }));\n        resolve(!newEditCellPropsProcessed.error);\n      });\n    });\n  }, [apiRef]);\n  var cellEditingApi = {\n    setCellMode: setCellMode,\n    getCellMode: getCellMode,\n    commitCellChange: commitCellChange,\n    unstable_setCellEditingEditCellValue: setCellEditingEditCellValue\n  };\n  useGridApiMethod(apiRef, cellEditingApi, 'EditRowApi');\n  var handleCellKeyDown = React.useCallback( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(params, event) {\n      var id, field, cellMode, isEditable, isEditMode, isModifierKeyPressed, commitParams, isValid;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = params.id, field = params.field, cellMode = params.cellMode, isEditable = params.isEditable;\n\n              if (isEditable) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              isEditMode = cellMode === GridCellModes.Edit;\n              isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;\n\n              if (!isEditMode && isCellEnterEditModeKeys(event.key) && !isModifierKeyPressed && !(event.key === ' ' && event.shiftKey)) {\n                apiRef.current.publishEvent(GridEvents.cellEditStart, params, event);\n              }\n\n              if (!isEditMode && isDeleteKeys(event.key)) {\n                apiRef.current.setEditCellValue({\n                  id: id,\n                  field: field,\n                  value: ''\n                });\n                apiRef.current.commitCellChange({\n                  id: id,\n                  field: field\n                }, event);\n                apiRef.current.publishEvent(GridEvents.cellEditStop, params, event);\n              }\n\n              if (!(isEditMode && isCellEditCommitKeys(event.key))) {\n                _context.next = 14;\n                break;\n              }\n\n              commitParams = {\n                id: id,\n                field: field\n              };\n              _context.next = 11;\n              return apiRef.current.commitCellChange(commitParams, event);\n\n            case 11:\n              isValid = _context.sent;\n\n              if (isValid) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 14:\n              if (isEditMode && isCellExitEditModeKeys(event.key)) {\n                apiRef.current.publishEvent(GridEvents.cellEditStop, params, event);\n              }\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [apiRef]);\n  var handleCellDoubleClick = React.useCallback(function (params, event) {\n    if (!params.isEditable) {\n      return;\n    }\n\n    apiRef.current.publishEvent(GridEvents.cellEditStart, params, event);\n  }, [apiRef]);\n\n  var commitPropsAndExit = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params, event) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(params.cellMode === GridCellModes.View)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              _context2.next = 4;\n              return apiRef.current.commitCellChange(params, event);\n\n            case 4:\n              apiRef.current.publishEvent(GridEvents.cellEditStop, params, event);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function commitPropsAndExit(_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var handleCellFocusOut = useEventCallback(function (params, event) {\n    commitPropsAndExit(params, event);\n  });\n  var handleColumnHeaderDragStart = useEventCallback(function () {\n    var cell = gridFocusCellSelector(apiRef);\n\n    if (!cell) {\n      return;\n    }\n\n    var params = apiRef.current.getCellParams(cell.id, cell.field);\n    commitPropsAndExit(params, {});\n  });\n  var handleCellEditStart = React.useCallback(function (params, event) {\n    if (!params.isEditable) {\n      return;\n    }\n\n    apiRef.current.setCellMode(params.id, params.field, GridCellModes.Edit);\n\n    if (isKeyboardEvent(event) && isPrintableKey(event.key)) {\n      apiRef.current.unstable_setEditCellProps({\n        id: params.id,\n        field: params.field,\n        props: {\n          value: ''\n        }\n      });\n    }\n  }, [apiRef]);\n  var handleCellEditStop = React.useCallback(function (params, event) {\n    apiRef.current.setCellMode(params.id, params.field, GridCellModes.View);\n\n    if (!isKeyboardEvent(event)) {\n      return;\n    }\n\n    if (isCellEditCommitKeys(event.key)) {\n      apiRef.current.publishEvent(GridEvents.cellNavigationKeyDown, params, event);\n      return;\n    }\n\n    if (event.key === 'Escape' || isDeleteKeys(event.key)) {\n      apiRef.current.setCellFocus(params.id, params.field);\n    }\n  }, [apiRef]);\n  var handleCellEditCommit = React.useCallback(function (params) {\n    var id = params.id,\n        field = params.field;\n    var model = apiRef.current.getEditRowsModel();\n    var value = model[id][field].value;\n    logger.debug(\"Setting cell id: \".concat(id, \" field: \").concat(field, \" to value: \").concat(value == null ? void 0 : value.toString()));\n    var row = apiRef.current.getRow(id);\n\n    if (row) {\n      var column = apiRef.current.getColumn(params.field);\n\n      var rowUpdate = _extends({}, row, _defineProperty({}, field, value));\n\n      if (column.valueSetter) {\n        rowUpdate = column.valueSetter({\n          row: row,\n          value: value\n        });\n      }\n\n      apiRef.current.updateRows([rowUpdate]);\n    }\n  }, [apiRef, logger]);\n  var handleEditCellPropsChange = React.useCallback(function (params) {\n    var row = apiRef.current.getRow(params.id);\n    var column = apiRef.current.getColumn(params.field);\n    var editCellProps = column.preProcessEditCellProps ? column.preProcessEditCellProps({\n      id: params.id,\n      row: row,\n      props: params.props\n    }) : params.props;\n\n    if (isPromise(editCellProps)) {\n      editCellProps.then(function (newEditCellProps) {\n        apiRef.current.unstable_setEditCellProps(_extends({}, params, {\n          props: newEditCellProps\n        }));\n      });\n    } else {\n      apiRef.current.unstable_setEditCellProps(_extends({}, params, {\n        props: editCellProps\n      }));\n    }\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, buildCallback(handleCellKeyDown));\n  useGridApiEventHandler(apiRef, GridEvents.cellDoubleClick, buildCallback(handleCellDoubleClick));\n  useGridApiEventHandler(apiRef, GridEvents.cellFocusOut, buildCallback(handleCellFocusOut));\n  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragStart, buildCallback(handleColumnHeaderDragStart));\n  useGridApiEventHandler(apiRef, GridEvents.cellEditStart, buildCallback(handleCellEditStart));\n  useGridApiEventHandler(apiRef, GridEvents.cellEditStop, buildCallback(handleCellEditStop));\n  useGridApiEventHandler(apiRef, GridEvents.cellEditCommit, buildCallback(handleCellEditCommit));\n  useGridApiEventHandler(apiRef, GridEvents.editCellPropsChange, buildCallback(handleEditCellPropsChange));\n  useGridApiOptionHandler(apiRef, GridEvents.cellEditCommit, props.onCellEditCommit);\n  useGridApiOptionHandler(apiRef, GridEvents.cellEditStart, props.onCellEditStart);\n  useGridApiOptionHandler(apiRef, GridEvents.cellEditStop, props.onCellEditStop);\n};","map":null,"metadata":{},"sourceType":"module"}