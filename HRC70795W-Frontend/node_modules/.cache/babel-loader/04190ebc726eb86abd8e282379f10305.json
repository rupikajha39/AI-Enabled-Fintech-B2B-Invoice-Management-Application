{"ast":null,"code":"import _defineProperty from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { checkGridRowIdIsValid } from '../../../models/gridRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  var id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nvar convertGridRowsPropToState = function convertGridRowsPropToState(_ref) {\n  var prevState = _ref.prevState,\n      rows = _ref.rows,\n      getRowId = _ref.getRowId;\n  var value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      ids: []\n    };\n\n    for (var i = 0; i < rows.length; i += 1) {\n      var row = rows[i];\n      var id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value: value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nvar getRowsStateFromCache = function getRowsStateFromCache(rowsCache, previousTree, apiRef, rowCountProp) {\n  var value = rowsCache.state.value;\n  var rowCount = rowCountProp != null ? rowCountProp : 0;\n  var groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', _extends({}, value, {\n    previousTree: previousTree\n  }));\n  var dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(function (node) {\n    return node.parent == null;\n  }).length;\n  return _extends({}, groupingResponse, {\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport var rowsStateInitializer = function rowsStateInitializer(state, props, apiRef) {\n  var rowsCache = {\n    state: convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: {\n        value: {\n          idRowsLookup: {},\n          ids: []\n        },\n        rowsBeforePartialUpdates: []\n      }\n    }),\n    timeout: null,\n    lastUpdateMs: Date.now()\n  };\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(rowsCache, null, apiRef, props.rowCount),\n    rowsCache: rowsCache // TODO remove from state\n\n  });\n};\nexport var useGridRows = function useGridRows(apiRef, props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  var logger = useGridLogger(apiRef, 'useGridRows');\n  var rowsCache = React.useRef(apiRef.current.state.rowsCache); // To avoid listing rowsCache as useEffect dep\n\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var getRow = React.useCallback(function (id) {\n    var _gridRowsLookupSelect;\n\n    return (_gridRowsLookupSelect = gridRowsLookupSelector(apiRef)[id]) != null ? _gridRowsLookupSelect : null;\n  }, [apiRef]);\n  var lookup = React.useMemo(function () {\n    return currentPage.rows.reduce(function (acc, _ref2, index) {\n      var id = _ref2.id;\n      acc[id] = index;\n      return acc;\n    }, {});\n  }, [currentPage.rows]);\n  var throttledRowsChange = React.useCallback(function (newState, throttle) {\n    var run = function run() {\n      rowsCache.current.timeout = null;\n      rowsCache.current.lastUpdateMs = Date.now();\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          rows: getRowsStateFromCache(rowsCache.current, gridRowTreeSelector(apiRef), apiRef, props.rowCount)\n        });\n      });\n      apiRef.current.publishEvent(GridEvents.rowsSet);\n      apiRef.current.forceUpdate();\n    };\n\n    if (rowsCache.current.timeout) {\n      clearTimeout(rowsCache.current.timeout);\n    }\n\n    rowsCache.current.state = newState;\n    rowsCache.current.timeout = null;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    var throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - rowsCache.current.lastUpdateMs);\n\n    if (throttleRemainingTimeMs > 0) {\n      rowsCache.current.timeout = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  var setRows = React.useCallback(function (rows) {\n    logger.debug(\"Updating all rows, new length \".concat(rows.length));\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: rows,\n      prevState: rowsCache.current.state,\n      getRowId: props.getRowId\n    }), true);\n  }, [logger, props.getRowId, throttledRowsChange]);\n  var updateRows = React.useCallback(function (updates) {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    var uniqUpdates = new Map();\n    updates.forEach(function (update) {\n      var id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    var deletedRowIds = [];\n    var newStateValue = {\n      idRowsLookup: _extends({}, rowsCache.current.state.value.idRowsLookup),\n      ids: _toConsumableArray(rowsCache.current.state.value.ids)\n    };\n    uniqUpdates.forEach(function (partialRow, id) {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      var oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(function (id) {\n        return !deletedRowIds.includes(id);\n      });\n    }\n\n    var state = _extends({}, rowsCache.current.state, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [apiRef, props.getRowId, throttledRowsChange, props.signature]);\n  var getRowModels = React.useCallback(function () {\n    var allRows = gridRowIdsSelector(apiRef);\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(function (id) {\n      return [id, idRowsLookup[id]];\n    }));\n  }, [apiRef]);\n  var getRowsCount = React.useCallback(function () {\n    return gridRowCountSelector(apiRef);\n  }, [apiRef]);\n  var getAllRowIds = React.useCallback(function () {\n    return gridRowIdsSelector(apiRef);\n  }, [apiRef]);\n  var getRowIndexRelativeToVisibleRows = React.useCallback(function (id) {\n    return lookup[id];\n  }, [lookup]);\n  var setRowChildrenExpansion = React.useCallback(function (id, isExpanded) {\n    var currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(\"MUI: No row with id #\".concat(id, \" found\"));\n    }\n\n    var newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, _defineProperty({}, id, newNode))\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.rowExpansionChange, newNode);\n  }, [apiRef]);\n  var getRowNode = React.useCallback(function (id) {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  var rowApi = {\n    getRow: getRow,\n    getRowModels: getRowModels,\n    getRowsCount: getRowsCount,\n    getAllRowIds: getAllRowIds,\n    setRows: setRows,\n    updateRows: updateRows,\n    setRowChildrenExpansion: setRowChildrenExpansion,\n    getRowNode: getRowNode,\n    getRowIndexRelativeToVisibleRows: getRowIndexRelativeToVisibleRows\n  };\n  /**\n   * EVENTS\n   */\n\n  var groupRows = React.useCallback(function () {\n    logger.info(\"Row grouping pre-processing have changed, regenerating the row tree\");\n    var rows;\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [logger, throttledRowsChange, props.getRowId, props.rows]);\n  var handleStrategyProcessorChange = React.useCallback(function (methodName) {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  var handleStrategyActivityChange = React.useCallback(function () {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, GridEvents.activeStrategyProcessorChange, handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, GridEvents.strategyAvailabilityChange, handleStrategyActivityChange);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(function () {\n    return function () {\n      if (rowsCache.current.timeout !== null) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        clearTimeout(rowsCache.current.timeout);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `GridEvents.rowGroupsPreProcessingChange` listener)\n\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(\"Updating all rows, new length \".concat(props.rows.length));\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange]);\n};","map":null,"metadata":{},"sourceType":"module"}