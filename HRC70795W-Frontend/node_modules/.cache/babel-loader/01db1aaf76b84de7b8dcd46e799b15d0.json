{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"D:\\\\HRC70795W-Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiEventHandler, useGridApiOptionHandler } from '../../utils/useGridApiEventHandler';\nimport { GridEvents } from '../../../models/events/gridEvents';\nimport { GridEditModes, GridCellModes } from '../../../models/gridEditRowModel';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridEditRowsStateSelector } from './gridEditRowsSelector';\nimport { isPrintableKey } from '../../../utils/keyboardUtils';\nimport { GridCellEditStartReasons, GridCellEditStopReasons } from '../../../models/params/gridEditCellParams';\nexport var useGridCellEditing = function useGridCellEditing(apiRef, props) {\n  var processRowUpdate = props.processRowUpdate;\n\n  var runIfEditModeIsCell = function runIfEditModeIsCell(callback) {\n    return function () {\n      if (props.editMode === GridEditModes.Cell) {\n        callback.apply(void 0, arguments);\n      }\n    };\n  };\n\n  var throwIfNotEditable = React.useCallback(function (id, field) {\n    var params = apiRef.current.getCellParams(id, field);\n\n    if (!apiRef.current.isCellEditable(params)) {\n      throw new Error(\"MUI: The cell with id=\".concat(id, \" and field=\").concat(field, \" is not editable.\"));\n    }\n  }, [apiRef]);\n  var throwIfNotInMode = React.useCallback(function (id, field, mode) {\n    if (apiRef.current.getCellMode(id, field) !== mode) {\n      throw new Error(\"MUI: The cell with id=\".concat(id, \" and field=\").concat(field, \" is not in \").concat(mode, \" mode.\"));\n    }\n  }, [apiRef]);\n  var handleCellDoubleClick = React.useCallback(function (params, event) {\n    if (!params.isEditable) {\n      return;\n    }\n\n    if (params.cellMode === GridCellModes.Edit) {\n      return;\n    }\n\n    var newParams = _extends({}, params, {\n      reason: GridCellEditStartReasons.cellDoubleClick\n    });\n\n    apiRef.current.publishEvent(GridEvents.cellEditStart, newParams, event);\n  }, [apiRef]);\n  var handleCellFocusOut = React.useCallback(function (params, event) {\n    if (params.cellMode === GridCellModes.View) {\n      return;\n    }\n\n    var newParams = _extends({}, params, {\n      reason: GridCellEditStopReasons.cellFocusOut\n    });\n\n    apiRef.current.publishEvent(GridEvents.cellEditStop, newParams, event);\n  }, [apiRef]);\n  var handleCellKeyDown = React.useCallback(function (params, event) {\n    if (params.cellMode === GridCellModes.Edit) {\n      var reason;\n\n      if (event.key === 'Escape') {\n        reason = GridCellEditStopReasons.escapeKeyDown;\n      } else if (event.key === 'Enter') {\n        reason = GridCellEditStopReasons.enterKeyDown;\n      } else if (event.key === 'Tab') {\n        reason = event.shiftKey ? GridCellEditStopReasons.shiftTabKeyDown : GridCellEditStopReasons.tabKeyDown;\n        event.preventDefault(); // Prevent going to the next element in the tab sequence\n      }\n\n      if (reason) {\n        var newParams = _extends({}, params, {\n          reason: reason\n        });\n\n        apiRef.current.publishEvent(GridEvents.cellEditStop, newParams, event);\n      }\n    } else if (params.isEditable) {\n      var _reason;\n\n      if (isPrintableKey(event.key)) {\n        if (event.shiftKey || event.ctrlKey || event.metaKey || event.altKey) {\n          return;\n        }\n\n        _reason = GridCellEditStartReasons.printableKeyDown;\n      } else if (event.key === 'Enter') {\n        _reason = GridCellEditStartReasons.enterKeyDown;\n      } else if (event.key === 'Delete') {\n        _reason = GridCellEditStartReasons.deleteKeyDown;\n      }\n\n      if (_reason) {\n        var _newParams = _extends({}, params, {\n          reason: _reason\n        });\n\n        apiRef.current.publishEvent(GridEvents.cellEditStart, _newParams, event);\n      }\n    }\n  }, [apiRef]);\n  var handleCellEditStart = React.useCallback(function (params, event) {\n    var id = params.id,\n        field = params.field,\n        reason = params.reason;\n    apiRef.current.startCellEditMode(params);\n\n    if (reason === GridCellEditStartReasons.deleteKeyDown || reason === GridCellEditStartReasons.printableKeyDown) {\n      apiRef.current.setEditCellValue({\n        id: id,\n        field: field,\n        value: ''\n      }, event);\n    }\n  }, [apiRef]);\n  var handleCellEditStop = React.useCallback(function (params) {\n    var id = params.id,\n        field = params.field,\n        reason = params.reason;\n    var cellToFocusAfter;\n\n    if (reason === GridCellEditStopReasons.enterKeyDown) {\n      cellToFocusAfter = 'below';\n    } else if (reason === GridCellEditStopReasons.tabKeyDown) {\n      cellToFocusAfter = 'right';\n    } else if (reason === GridCellEditStopReasons.shiftTabKeyDown) {\n      cellToFocusAfter = 'left';\n    }\n\n    var ignoreModifications = reason === 'escapeKeyDown';\n    var editingState = gridEditRowsStateSelector(apiRef.current.state);\n\n    if (editingState[id][field].isProcessingProps) {\n      // The user wants to stop editing the cell but we can't wait for the props to be processed.\n      // In this case, discard the modifications.\n      ignoreModifications = true;\n    }\n\n    apiRef.current.stopCellEditMode({\n      id: id,\n      field: field,\n      ignoreModifications: ignoreModifications,\n      cellToFocusAfter: cellToFocusAfter\n    });\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, GridEvents.cellDoubleClick, runIfEditModeIsCell(handleCellDoubleClick));\n  useGridApiEventHandler(apiRef, GridEvents.cellFocusOut, runIfEditModeIsCell(handleCellFocusOut));\n  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, runIfEditModeIsCell(handleCellKeyDown));\n  useGridApiEventHandler(apiRef, GridEvents.cellEditStart, runIfEditModeIsCell(handleCellEditStart));\n  useGridApiEventHandler(apiRef, GridEvents.cellEditStop, runIfEditModeIsCell(handleCellEditStop));\n  useGridApiOptionHandler(apiRef, GridEvents.cellEditStart, props.onCellEditStart);\n  useGridApiOptionHandler(apiRef, GridEvents.cellEditStop, props.onCellEditStop);\n  var getCellMode = React.useCallback(function (id, field) {\n    var editingState = gridEditRowsStateSelector(apiRef.current.state);\n    var isEditing = editingState[id] && editingState[id][field];\n    return isEditing ? GridCellModes.Edit : GridCellModes.View;\n  }, [apiRef]);\n  var updateOrDeleteFieldState = React.useCallback(function (id, field, newProps) {\n    apiRef.current.setState(function (state) {\n      var newEditingState = _extends({}, state.editRows);\n\n      if (newProps !== null) {\n        newEditingState[id] = _extends({}, newEditingState[id], _defineProperty({}, field, _extends({}, newProps)));\n      } else {\n        delete newEditingState[id][field];\n\n        if (Object.keys(newEditingState[id]).length === 0) {\n          delete newEditingState[id];\n        }\n      }\n\n      return _extends({}, state, {\n        editRows: newEditingState\n      });\n    });\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  var startCellEditMode = React.useCallback(function (params) {\n    var id = params.id,\n        field = params.field;\n    throwIfNotEditable(id, field);\n    throwIfNotInMode(id, field, GridCellModes.View);\n    var newProps = {\n      value: apiRef.current.getCellValue(id, field),\n      error: false,\n      isProcessingProps: false\n    };\n    updateOrDeleteFieldState(id, field, newProps);\n    apiRef.current.setCellFocus(id, field);\n  }, [apiRef, throwIfNotEditable, throwIfNotInMode, updateOrDeleteFieldState]);\n  var stopCellEditMode = React.useCallback(function (params) {\n    var id = params.id,\n        field = params.field,\n        ignoreModifications = params.ignoreModifications,\n        _params$cellToFocusAf = params.cellToFocusAfter,\n        cellToFocusAfter = _params$cellToFocusAf === void 0 ? 'none' : _params$cellToFocusAf;\n    throwIfNotInMode(id, field, GridCellModes.Edit);\n    apiRef.current.unstable_runPendingEditCellValueMutation(id, field);\n\n    var updateFocusedCellIfNeeded = function updateFocusedCellIfNeeded() {\n      if (cellToFocusAfter !== 'none') {\n        apiRef.current.unstable_moveFocusToRelativeCell(id, field, cellToFocusAfter);\n      }\n    };\n\n    if (ignoreModifications) {\n      updateFocusedCellIfNeeded();\n      updateOrDeleteFieldState(id, field, null);\n      return;\n    }\n\n    var editingState = gridEditRowsStateSelector(apiRef.current.state);\n    var row = apiRef.current.getRow(id);\n    var column = apiRef.current.getColumn(field);\n    var _editingState$id$fiel = editingState[id][field],\n        value = _editingState$id$fiel.value,\n        error = _editingState$id$fiel.error,\n        isProcessingProps = _editingState$id$fiel.isProcessingProps;\n\n    if (error || isProcessingProps) {\n      return;\n    }\n\n    var rowUpdate = column.valueSetter ? column.valueSetter({\n      value: value,\n      row: row\n    }) : _extends({}, row, _defineProperty({}, field, value));\n\n    if (processRowUpdate) {\n      Promise.resolve(processRowUpdate(rowUpdate, row)).then(function (finalRowUpdate) {\n        apiRef.current.updateRows([finalRowUpdate]);\n        updateFocusedCellIfNeeded();\n        updateOrDeleteFieldState(id, field, null);\n      });\n    } else {\n      apiRef.current.updateRows([rowUpdate]);\n      updateFocusedCellIfNeeded();\n      updateOrDeleteFieldState(id, field, null);\n    }\n  }, [apiRef, processRowUpdate, throwIfNotInMode, updateOrDeleteFieldState]);\n  var setCellEditingEditCellValue = React.useCallback( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(params) {\n      var id, field, value, column, row, parsedValue, editingState, newProps, hasChanged;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = params.id, field = params.field, value = params.value;\n              throwIfNotEditable(id, field);\n              throwIfNotInMode(id, field, GridCellModes.Edit);\n              column = apiRef.current.getColumn(field);\n              row = apiRef.current.getRow(id);\n              parsedValue = value;\n\n              if (column.valueParser) {\n                parsedValue = column.valueParser(value, apiRef.current.getCellParams(id, field));\n              }\n\n              editingState = gridEditRowsStateSelector(apiRef.current.state);\n              newProps = _extends({}, editingState[id][field], {\n                value: parsedValue\n              });\n\n              if (!column.preProcessEditCellProps) {\n                _context.next = 16;\n                break;\n              }\n\n              hasChanged = value !== editingState[id][field].value;\n              newProps = _extends({}, newProps, {\n                isProcessingProps: true\n              });\n              updateOrDeleteFieldState(id, field, newProps);\n              _context.next = 15;\n              return Promise.resolve(column.preProcessEditCellProps({\n                id: id,\n                row: row,\n                props: newProps,\n                hasChanged: hasChanged\n              }));\n\n            case 15:\n              newProps = _context.sent;\n\n            case 16:\n              if (!(apiRef.current.getCellMode(id, field) === GridCellModes.View)) {\n                _context.next = 18;\n                break;\n              }\n\n              return _context.abrupt(\"return\", false);\n\n            case 18:\n              editingState = gridEditRowsStateSelector(apiRef.current.state);\n              newProps = _extends({}, newProps, {\n                isProcessingProps: false\n              }); // We don't update the value with the one coming from the props pre-processing\n              // because when the promise resolves it may be already outdated. The only\n              // exception to this rule is when there's no pre-processing.\n\n              newProps.value = column.preProcessEditCellProps ? editingState[id][field].value : parsedValue;\n              updateOrDeleteFieldState(id, field, newProps);\n              editingState = gridEditRowsStateSelector(apiRef.current.state);\n              return _context.abrupt(\"return\", !editingState[id][field].error);\n\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [apiRef, throwIfNotEditable, throwIfNotInMode, updateOrDeleteFieldState]);\n  var editingApi = {\n    getCellMode: getCellMode,\n    startCellEditMode: startCellEditMode,\n    stopCellEditMode: stopCellEditMode,\n    unstable_setCellEditingEditCellValue: setCellEditingEditCellValue\n  };\n  useGridApiMethod(apiRef, editingApi, 'EditingApi');\n};","map":null,"metadata":{},"sourceType":"module"}